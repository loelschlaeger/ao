[{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"what-actually-is-alternating-optimization","dir":"Articles","previous_headings":"","what":"What actually is alternating optimization?","title":"Alternating optimization","text":"Alternating optimization (AO) iterative procedure used optimize multivariate function breaking simpler sub-problems. involves optimizing one block function parameters keeping others fixed, alternating process among parameter blocks. AO particularly useful sub-problems easier solve original joint optimization problem, natural partition parameters. Mathematically, consider real-valued objective function f(𝐱,𝐲)f(\\mathbf{x}, \\mathbf{y}) 𝐱\\mathbf{x} 𝐲\\mathbf{y} two blocks function parameters, namely partition parameters. AO procedure can described follows: Initialization: Start initial guesses 𝐱(0)\\mathbf{x}^{(0)} 𝐲(0)\\mathbf{y}^{(0)}. Iterative Steps: k=0,1,2,…k = 0, 1, 2, \\dots Step 1: Fix 𝐲=𝐲(k)\\mathbf{y} = \\mathbf{y}^{(k)} solve sub-problem 𝐱(k+1)=argmin𝐱f(𝐱,𝐲(k)).\\mathbf{x}^{(k+1)} = \\arg \\min_{\\mathbf{x}} f(\\mathbf{x}, \\mathbf{y}^{(k)}). Step 2: Fix 𝐱=𝐱(k+1)\\mathbf{x} = \\mathbf{x}^{(k+1)} solve sub-problem 𝐲(k+1)=argmin𝐲f(𝐱(k+1),𝐲).\\mathbf{y}^{(k+1)} = \\arg \\min_{\\mathbf{y}} f(\\mathbf{x}^{(k+1)}, \\mathbf{y}). Convergence: Repeat iterative steps convergence criterion met, change objective function parameters falls specified threshold, pre-defined iteration limit reached. AO procedure can viewed generalization joint optimization, parameter partition trivial, consisting entire parameter vector single block, also used maximization problems simply replacing argmin\\arg \\min argmax\\arg \\max , generalized two parameter blocks, .e., f(𝐱1,𝐱2,…,𝐱n)f(\\mathbf{x}_1, \\mathbf{x}_2, \\ldots, \\mathbf{x}_n), procedure involves cycling parameter block 𝐱1,𝐱2,…,𝐱n\\mathbf{x}_1, \\mathbf{x}_2, \\ldots, \\mathbf{x}_n solving corresponding sub-problems iteratively (parameter blocks necessarily disjoint), randomized changing parameter partition randomly iteration, can improve convergence rate help avoid getting trapped local optima (Chib Ramamurthy 2010), run multiple threads different initial values, parameter partitions, /base optimizers.","code":""},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"now-how-to-use-the-ao-package","dir":"Articles","previous_headings":"","what":"Now how to use the {ao} package?","title":"Alternating optimization","text":"ao package offers function ao(), can used perform different variants alternating optimization.","code":""},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"the-function-call","dir":"Articles","previous_headings":"Now how to use the {ao} package?","what":"The function call","title":"Alternating optimization","text":"ao() function call default arguments looks follows: arguments following meaning: f: objective function optimized. default, f optimized first argument. optimization target different argument multiple arguments, use npar target, see . Additional arguments f can passed via ... argument usual. initial: Initial values parameters used AO procedure. gradient: Optional argument specify analytical gradient f. provided, finite-difference approximation used. partition: Specifies parameters partitioned optimization. Can one following: \"sequential\": Optimizes parameter block sequentially. \"random\": Randomly partitions parameters iteration. \"none\": partitioning; equivalent joint optimization. Custom partition can defined using list vectors parameter indices. new_block_probability minimum_block_number relevant partition = \"random\". case, former controls probability creating new block, latter defines minimum number parameter blocks. minimize: Set TRUE minimization problems (default), FALSE maximization. lower upper: Lower upper limits constrained optimization. iteration_limit maximum number AO iterations termination, seconds_limit time limit seconds. tolerance_value tolerance_parameter (combination tolerance_parameter_norm) specify two stopping criteria, namely difference current function value current parameter vector one tolerance_history iterations, respectively, becomes smaller thresholds. base_optimizer: Numerical optimizer used solving sub-problems. Set verbose TRUE print status messages, hide_warnings FALSE show warning messages AO process.","code":"ao(   f,   initial,   target = NULL,   npar = NULL,   gradient = NULL,   ...,   partition = \"sequential\",   new_block_probability = 0.5,   minimum_block_number = 2,   minimize = TRUE,   lower = -Inf,   upper = Inf,   iteration_limit = Inf,   seconds_limit = Inf,   tolerance_value = 1e-6,   tolerance_parameter = 1e-6,   tolerance_parameter_norm = function(x, y) sqrt(sum((x - y)^2)),   tolerance_history = 1,   base_optimizer = Optimizer$new(\"stats::optim\", method = \"L-BFGS-B\"),   verbose = FALSE,   hide_warnings = TRUE )"},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"a-simple-first-example","dir":"Articles","previous_headings":"Now how to use the {ao} package?","what":"A simple first example","title":"Alternating optimization","text":"following implementation Himmelblau’s function f(x,y)=(x2+y−11)2+(x+y2−7)2:f(x, y) = (x^2 + y - 11)^2 + (x + y^2 - 7)^2: function four identical local minima, example x=3x = 3 y=2y = 2:  Minimizing Himmelblau’s function alternating minimization 𝐱\\mathbf{x} 𝐲\\mathbf{y} initial values 𝐱(0)=𝐲(0)=0\\mathbf{x}^{(0)} = \\mathbf{y}^{(0)} = 0 can accomplished follows: , see output alternating optimization procedure, list contains following elements: estimate parameter vector termination. value function value termination. details data.frame full information procedure: iteration (column iteration) contains function value (column value), parameter values (columns starting p followed parameter index), active parameter block (columns starting b followed parameter index, 1 stands parameter contained active parameter block 0 ), computation times seconds (column seconds). seconds overall computation time seconds. stopping_reason message procedure terminated.","code":"himmelblau <- function(x) (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2 himmelblau(c(3, 2)) #> [1] 0 ao(f = himmelblau, initial = c(0, 0)) #> $estimate #> [1]  3.584428 -1.848126 #>  #> $value #> [1] 9.606386e-12 #>  #> $details #>    iteration        value       p1        p2 b1 b2     seconds #> 1          0 1.700000e+02 0.000000  0.000000  0  0 0.000000000 #> 2          1 1.327270e+01 3.395691  0.000000  1  0 0.018008232 #> 3          1 1.743664e+00 3.395691 -1.803183  0  1 0.003805161 #> 4          2 2.847290e-02 3.581412 -1.803183  1  0 0.003932714 #> 5          2 4.687468e-04 3.581412 -1.847412  0  1 0.003320694 #> 6          3 7.368057e-06 3.584381 -1.847412  1  0 0.002850771 #> 7          3 1.164202e-07 3.584381 -1.848115  0  1 0.022559643 #> 8          4 1.893311e-09 3.584427 -1.848115  1  0 0.002321720 #> 9          4 9.153860e-11 3.584427 -1.848124  0  1 0.001801968 #> 10         5 6.347425e-11 3.584428 -1.848124  1  0 0.001797199 #> 11         5 9.606386e-12 3.584428 -1.848126  0  1 0.001785517 #>  #> $seconds #> [1] 0.06218362 #>  #> $stopping_reason #> [1] \"change in function value between 1 iteration is < 1e-06\""},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"using-the-analytical-gradient","dir":"Articles","previous_headings":"Now how to use the {ao} package?","what":"Using the analytical gradient","title":"Alternating optimization","text":"Himmelblau’s function, straightforward define analytical gradient follows: gradient function used ao() defined gradient argument follows: output shown closely resembles previous example, gradient specified thus finite-difference approximation employed. However, scenarios involving higher dimensions, utilizing analytical gradient can notably improve speed stability process.","code":"gradient <- function(x) {   c(     4 * x[1] * (x[1]^2 + x[2] - 11) + 2 * (x[1] + x[2]^2 - 7),     2 * (x[1]^2 + x[2] - 11) + 4 * x[2] * (x[1] + x[2]^2 - 7)   ) } ao(f = himmelblau, initial = c(0, 0), gradient = gradient)"},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"random-parameter-partitions","dir":"Articles","previous_headings":"Now how to use the {ao} package?","what":"Random parameter partitions","title":"Alternating optimization","text":"Another version AO procedure involves using new, random partition parameters every iteration. approach can enhance convergence rate prevent stuck local optima. activated setting partition = \"random\". randomness can adjusted using two parameters: new_block_probability determines probability creating new block building new partition. value ranges 0 (blocks created) 1 (parameter single block). minimum_block_number sets minimum number parameter blocks random partitions. default, configured 2 avoid generating trivial partitions. random partitions build follows:1 example AO random partitions, consider fitting two-class Gaussian mixture model via maximizing model’s log-likelihood function ℓ(𝛉)=∑=1nlog(λϕμ1,σ12(xi)+(1−λ)ϕμ2,σ22(xi)),\\ell(\\boldsymbol{\\theta}) = \\sum_{=1}^n \\log\\Big( \\lambda \\phi_{\\mu_1, \\sigma_1^2}(x_i) + (1-\\lambda)\\phi_{\\mu_2,\\sigma_2^2} (x_i) \\Big), sum goes observations 1,…,n1, \\dots, n, ϕμ1,σ12\\phi_{\\mu_1, \\sigma_1^2} ϕμ2,σ22\\phi_{\\mu_2, \\sigma_2^2} denote normal density first second cluster, respectively, λ\\lambda mixing proportion. parameter vector estimated thus 𝛉=(μ1,μ2,σ1,σ2,λ)\\boldsymbol{\\theta} = (\\mu_1, \\mu_2, \\sigma_1, \\sigma_2, \\lambda). exists closed-form solution maximum likelihood estimator 𝛉*=argmax𝛉ℓ(𝛉)\\boldsymbol{\\theta}^* = \\arg\\max_{\\boldsymbol{\\theta}} \\ell(\\boldsymbol{\\theta}), need numerical optimization finding function optimum. model fitted following data:2  following function calculates log-likelihood value given parameter vector theta observation vector data:3 ao() call performing alternating maximization random partitions looks follows, simplified output brevity:","code":"procedure <- ao:::Procedure$new(   npar = 10,   partition = \"random\",   new_block_probability = 0.5,   minimum_block_number = 2 ) procedure$get_partition() #> [[1]] #> [1] 5 #>  #> [[2]] #> [1] 1 6 9 #>  #> [[3]] #> [1] 10 #>  #> [[4]] #> [1] 7 #>  #> [[5]] #> [1] 4 8 #>  #> [[6]] #> [1] 2 3 procedure$get_partition() #> [[1]] #> [1] 1 7 8 #>  #> [[2]] #> [1]  6 10 #>  #> [[3]] #> [1] 3 4 #>  #> [[4]] #> [1] 2 #>  #> [[5]] #> [1] 9 #>  #> [[6]] #> [1] 5 normal_mixture_llk <- function(theta, data) {   mu <- theta[1:2]   sd <- exp(theta[3:4])   lambda <- plogis(theta[5])   c1 <- lambda * dnorm(data, mu[1], sd[1])   c2 <- (1 - lambda) * dnorm(data, mu[2], sd[2])   sum(log(c1 + c2)) } out <- ao(   f = normal_mixture_llk,   initial = runif(5),   data = datasets::faithful$eruptions,   partition = \"random\",   minimize = FALSE ) round(out$details, 2) #>    iteration   value   p1   p2    p3    p4    p5 b1 b2 b3 b4 b5 seconds #> 1          0 -713.98 0.94 0.79  0.97  0.35  0.50  0  0  0  0  0    0.00 #> 2          1 -541.18 0.94 3.81  0.97  0.35  0.50  0  1  0  0  0    0.00 #> 3          1 -512.65 0.94 3.81  0.66 -0.30  0.50  0  0  1  1  0    0.01 #> 4          1 -447.85 3.08 3.81  0.66 -0.30  0.50  1  0  0  0  0    0.00 #> 5          1 -445.29 3.08 3.81  0.66 -0.30 -0.04  0  0  0  0  1    0.00 #> 6          2 -432.41 3.08 4.23  0.66 -0.30 -0.04  0  1  0  0  0    0.00 #> 7          2 -277.05 2.02 4.23 -1.46 -0.81 -0.63  1  0  1  1  1    0.03 #> 8          3 -276.39 2.02 4.27 -1.46 -0.81 -0.63  0  1  0  0  1    0.01 #> 9          3 -276.36 2.02 4.27 -1.45 -0.83 -0.63  1  0  1  1  0    0.01 #> 10         4 -276.36 2.02 4.27 -1.45 -0.83 -0.63  0  0  1  0  0    0.01 #> 11         4 -276.36 2.02 4.27 -1.45 -0.83 -0.63  1  1  0  1  1    0.01 #> 12         5 -276.36 2.02 4.27 -1.45 -0.83 -0.63  1  0  0  0  0    0.00 #> 13         5 -276.36 2.02 4.27 -1.45 -0.83 -0.63  0  1  1  1  1    0.01 #> 14         6 -276.36 2.02 4.27 -1.45 -0.83 -0.63  0  0  0  0  1    0.00 #> 15         6 -276.36 2.02 4.27 -1.45 -0.83 -0.63  1  1  1  1  0    0.01 #> 16         7 -276.36 2.02 4.27 -1.45 -0.83 -0.63  1  1  0  1  1    0.01 #> 17         7 -276.36 2.02 4.27 -1.45 -0.83 -0.63  0  0  1  0  0    0.00 #> 18         8 -276.36 2.02 4.27 -1.45 -0.83 -0.63  1  1  0  1  1    0.00 #> 19         8 -276.36 2.02 4.27 -1.45 -0.83 -0.63  0  0  1  0  0    0.00"},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"more-flexibility","dir":"Articles","previous_headings":"Now how to use the {ao} package?","what":"More flexibility","title":"Alternating optimization","text":"ao package offers flexibility performing AO.4","code":""},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"generalized-objective-functions","dir":"Articles","previous_headings":"Now how to use the {ao} package? > More flexibility","what":"Generalized objective functions","title":"Alternating optimization","text":"Optimizers R generally require objective function single target argument must first position. ao allows optimization argument first, one argument. example, say, normal_mixture_llk function following form supposed optimized parameters mu, sd, lambda: ao(), scenario can specified setting target = c(\"mu\", \"sd\", \"lambda\") (names target arguments) npar = c(2, 2, 1) (lengths target arguments):","code":"normal_mixture_llk <- function(data, mu, sd, lambda) {   sd <- exp(sd)   lambda <- plogis(lambda)   c1 <- lambda * dnorm(data, mu[1], sd[1])   c2 <- (1 - lambda) * dnorm(data, mu[2], sd[2])   sum(log(c1 + c2)) } ao(   f = normal_mixture_llk,   initial = runif(5),   target = c(\"mu\", \"sd\", \"lambda\"),   npar = c(2, 2, 1),   data = datasets::faithful$eruptions,   partition = \"random\",   minimize = FALSE )"},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"parameter-bounds","dir":"Articles","previous_headings":"Now how to use the {ao} package? > More flexibility","what":"Parameter bounds","title":"Alternating optimization","text":"Instead using parameter transformations normal_mixture_llk() function , parameter bounds can directly specified ao() via arguments lower upper, can either single number (common bound parameters) vector specific bounds per parameter. Therefore, straightforward implementation mixture example :","code":"normal_mixture_llk <- function(mu, sd, lambda, data) {   c1 <- lambda * dnorm(data, mu[1], sd[1])   c2 <- (1 - lambda) * dnorm(data, mu[2], sd[2])   sum(log(c1 + c2)) } ao(   f = normal_mixture_llk,   initial = runif(5),   target = c(\"mu\", \"sd\", \"lambda\"),   npar = c(2, 2, 1),   data = datasets::faithful$eruptions,   partition = \"random\",   minimize = FALSE,   lower = c(-Inf, -Inf, 0, 0, 0),   upper = c(Inf, Inf, Inf, Inf, 1) )"},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"custom-parameter-partition","dir":"Articles","previous_headings":"Now how to use the {ao} package? > More flexibility","what":"Custom parameter partition","title":"Alternating optimization","text":"ao allows specification custom parameter partitions. example, say, parameters Gaussian mixture model supposed grouped type: 𝐱1=(μ1,μ2),𝐱2=(σ1,σ2),𝐱3=(λ).\\mathbf{x}_1 = (\\mu_1, \\mu_2),\\ \\mathbf{x}_2 = (\\sigma_1, \\sigma_2),\\ \\mathbf{x}_3 = (\\lambda). ao(), custom parameter partitions can specified setting partition = list(1:2, 3:4, 5), .e. defining list element corresponds parameter block, containing vector parameter indices. Parameter indices can members number blocks.","code":""},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"stopping-criteria","dir":"Articles","previous_headings":"Now how to use the {ao} package? > More flexibility","what":"Stopping criteria","title":"Alternating optimization","text":"Currently, four different stopping criteria AO procedure implemented: predefined iteration limit exceeded (via iteration_limit argument) predefined time limit exceeded (via seconds_limit argument) absolute change function value comparison last iteration falls predefined threshold (via tolerance_value argument) change parameters comparison last iteration falls predefined threshold (via tolerance_parameter argument, parameter distance computed via norm specified tolerance_parameter_norm) number stopping criteria can activated deactivated5, final output contains information criterium caused termination.","code":""},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"optimizer-for-solving-the-sub-problems","dir":"Articles","previous_headings":"Now how to use the {ao} package? > More flexibility","what":"Optimizer for solving the sub-problems","title":"Alternating optimization","text":"default, L-BFGS-B algorithm (Byrd et al. 1995) implemented stats::optim used. solving sub-problems numerically. However, optimizer can selected specifying base_optimizer argument. optimizer must defined framework provided optimizeR package, please see documentation details. example, stats::nlm optimizer can selected setting base_optimizer = Optimizer$new(\"stats::nlm\").","code":""},{"path":"https://loelschlaeger.de/ao/articles/ao.html","id":"multiple-threads","dir":"Articles","previous_headings":"Now how to use the {ao} package? > More flexibility","what":"Multiple threads","title":"Alternating optimization","text":"Alternating optimization can suffer local optima. increase likelihood reaching global optimum, users can specify multiple starting parameters, multiple parameter partitions, multiple base optimizers. Use initial, partition, /base_optimizer arguments provide list possible values parameter. combination initial values, parameter partitions, base optimizers create separate alternating optimization thread. case multiple threads, output changes slightly comparison standard case. still list following elements: estimate optimal parameter vector threads. value optimal function value threads. details combines details single threads additional column thread index different threads. seconds gives computation time seconds thread. stopping_reason gives termination message thread. threads give details different threads specified. default, threads run sequentially. However, since independent, can parallelized. enable parallel computation, use {future} framework. example, run following ao() call: using multiple threads, setting verbose = TRUE print tracing details alternating optimization supported. However, progress threads can still tracked using {progressr} framework. example, run following ao() call:","code":"future::plan(future::multisession, workers = 4) progressr::handlers(global = TRUE) progressr::handlers(   progressr::handler_progress(\":percent :eta :message\") )"},{"path":[]},{"path":"https://loelschlaeger.de/ao/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lennart Oelschläger. Author, maintainer. Siddhartha Chib. Contributor.","code":""},{"path":"https://loelschlaeger.de/ao/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Oelschläger L (2024). ao: Alternating Optimization. R package version 1.1.0, https://github.com/loelschlaeger/ao/, https://loelschlaeger.de/ao/.","code":"@Manual{,   title = {ao: Alternating Optimization},   author = {Lennart Oelschläger},   year = {2024},   note = {R package version 1.1.0, https://github.com/loelschlaeger/ao/},   url = {https://loelschlaeger.de/ao/}, }"},{"path":"https://loelschlaeger.de/ao/index.html","id":"alternating-optimization-","dir":"","previous_headings":"","what":"Alternating Optimization","title":"Alternating Optimization","text":"ao package offers useRs easy access alternating optimization.","code":""},{"path":"https://loelschlaeger.de/ao/index.html","id":"why","dir":"","previous_headings":"","what":"Why?","title":"Alternating Optimization","text":"Alternating optimization iterative procedure optimizes function alternately performing restricted optimization individual parameter subsets. Instead tackling joint optimization directly, breaks problem simpler sub-problems. approach can make optimization feasible joint optimization difficult. details, please refer package vignette.","code":""},{"path":"https://loelschlaeger.de/ao/index.html","id":"how","dir":"","previous_headings":"","what":"How?","title":"Alternating Optimization","text":"can install released package version CRAN : load package via library(\"ao\") ready go. simple example alternating minimization Rosenbrock function: resulting optimization path …  … obtained follows:","code":"install.packages(\"ao\") rosenbrock <- function(x) (1 - x[1])^2 + (x[2] - x[1]^2)^2 ao(f = rosenbrock, initial = c(2, 2)) #> $estimate #> [1] 1.000895 1.001791 #>  #> $value #> [1] 8.016137e-07 #>  #> $details #>    iteration        value       p1       p2 b1 b2      seconds #> 1          0 5.000000e+00 2.000000 2.000000  0  0 0.0000000000 #> 2          1 1.519238e-01 1.366025 2.000000  1  0 0.0020544529 #> 3          1 1.339744e-01 1.366025 1.866024  0  1 0.0009624958 #> 4          2 1.176778e-01 1.320824 1.866024  1  0 0.0013415813 #> 5          2 1.029278e-01 1.320824 1.744575  0  1 0.0009355545 #> 6          3 8.966402e-02 1.278883 1.744575  1  0 0.0013275146 #> 7          3 7.777546e-02 1.278883 1.635540  0  1 0.0009441376 #> 8          4 6.719114e-02 1.240415 1.635540  1  0 0.0013272762 #> 9          4 5.779955e-02 1.240415 1.538630  0  1 0.0009331703 #> 10         5 4.952339e-02 1.205560 1.538630  1  0 0.0013463497 #> 11         5 4.225482e-02 1.205560 1.453374  0  1 0.0009357929 #> 12         6 3.591491e-02 1.174366 1.453374  1  0 0.0013477802 #> 13         6 3.040344e-02 1.174366 1.379135  0  1 0.0009481907 #> 14         7 2.564430e-02 1.146792 1.379135  1  0 0.0013115406 #> 15         7 2.154801e-02 1.146792 1.315133  0  1 0.0009262562 #> 16         8 1.804492e-02 1.122712 1.315133  1  0 0.0015296936 #> 17         8 1.505832e-02 1.122712 1.260483  0  1 0.0009601116 #> 18         9 1.252724e-02 1.101923 1.260483  1  0 0.0015218258 #> 19         9 1.038836e-02 1.101923 1.214235  0  1 0.0009334087 #> 20        10 8.590837e-03 1.084167 1.214235  1  0 0.0032966137 #> 21        10 7.084101e-03 1.084167 1.175418  0  1 0.0009722710 #> 22        11 5.827377e-03 1.069149 1.175418  1  0 0.0035614967 #> 23        11 4.781578e-03 1.069149 1.143079  0  1 0.0009627342 #> 24        12 3.915156e-03 1.056558 1.143079  1  0 0.0035083294 #> 25        12 3.198754e-03 1.056558 1.116314  0  1 0.0050704479 #> 26        13 2.608707e-03 1.046082 1.116314  1  0 0.0096364021 #> 27        13 2.123531e-03 1.046082 1.094287  0  1 0.0010223389 #> 28        14 1.725945e-03 1.037424 1.094287  1  0 0.0011823177 #> 29        14 1.400576e-03 1.037424 1.076249  0  1 0.0010311604 #> 30        15 1.135093e-03 1.030310 1.076249  1  0 0.0012366772 #> 31        15 9.187038e-04 1.030310 1.061539  0  1 0.0010347366 #> 32        16 7.427825e-04 1.024492 1.061539  1  0 0.0014419556 #> 33        16 5.998755e-04 1.024492 1.049585  0  1 0.0009484291 #> 34        17 4.840462e-04 1.019754 1.049585  1  0 0.0011548996 #> 35        17 3.902161e-04 1.019754 1.039898  0  1 0.0009682178 #> 36        18 3.143566e-04 1.015907 1.039898  1  0 0.0011923313 #> 37        18 2.530454e-04 1.015907 1.032068  0  1 0.0009942055 #> 38        19 2.035803e-04 1.012794 1.032068  1  0 0.0011959076 #> 39        19 1.636760e-04 1.012794 1.025751  0  1 0.0009624958 #> 40        20 1.315375e-04 1.010279 1.025751  1  0 0.0011341572 #> 41        20 1.056496e-04 1.010279 1.020663  0  1 0.0009608269 #> 42        21 8.482978e-05 1.008251 1.020663  1  0 0.0011692047 #> 43        21 6.807922e-05 1.008251 1.016570  0  1 0.0010235310 #> 44        22 5.462405e-05 1.006619 1.016570  1  0 0.0011668205 #> 45        22 4.380882e-05 1.006619 1.013281  0  1 0.0010051727 #> 46        23 3.513011e-05 1.005307 1.013281  1  0 0.0011425018 #> 47        23 2.815916e-05 1.005307 1.010641  0  1 0.0009336472 #> 48        24 2.257018e-05 1.004252 1.010641  1  0 0.0011336803 #> 49        24 1.808332e-05 1.004252 1.008523  0  1 0.0009269714 #> 50        25 1.448872e-05 1.003406 1.008523  1  0 0.0011277199 #> 51        25 1.160399e-05 1.003406 1.006825  0  1 0.0009322166 #> 52        26 9.294548e-06 1.002728 1.006825  1  0 0.0011436939 #> 53        26 7.441548e-06 1.002728 1.005463  0  1 0.0009248257 #> 54        27 5.959072e-06 1.002184 1.005463  1  0 0.0011191368 #> 55        27 4.769667e-06 1.002184 1.004373  0  1 0.0007314682 #> 56        28 3.818729e-06 1.001748 1.004373  1  0 0.0011234283 #> 57        28 3.055717e-06 1.001748 1.003499  0  1 0.0009295940 #> 58        29 2.446111e-06 1.001399 1.003499  1  0 0.0011372566 #> 59        29 1.956863e-06 1.001399 1.002800  0  1 0.0009288788 #> 60        30 1.566279e-06 1.001119 1.002800  1  0 0.0011575222 #> 61        30 1.252688e-06 1.001119 1.002240  0  1 0.0009603500 #> 62        31 1.002554e-06 1.000895 1.002240  1  0 0.0011262894 #> 63        31 8.016137e-07 1.000895 1.001791  0  1 0.0007302761 #>  #> $seconds #> [1] 0.08763027 #>  #> $stopping_reason #> [1] \"change in function value between 1 iteration is < 1e-06\""},{"path":"https://loelschlaeger.de/ao/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact?","title":"Alternating Optimization","text":"question, found bug, want request feature, give feedback, contribute, love hear . Please file issue GitHub. 😊","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":null,"dir":"Reference","previous_headings":"","what":"Procedure Object — Procedure","title":"Procedure Object — Procedure","text":"object specifies alternating optimization procedure.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Procedure Object — Procedure","text":"npar (integer(1)) length target argument. partition (character(1) list()) Defines parameter partition, can either \"sequential\" treating parameter separately, \"random\" random partition iteration, \"none\" partition (equivalent joint optimization), list vectors parameter indices, specifying custom partition alternating optimization process. new_block_probability (numeric(1)) relevant partition = \"random\". probability new parameter block creating random partitions. Values close 0 result larger parameter blocks, values close 1 result smaller parameter blocks. minimum_block_number (integer(1)) relevant partition = \"random\". minimum number blocks random partitions. verbose (logical(1)) Whether print tracing details alternating optimization process. minimize (logical(1)) Whether minimize alternating optimization process. FALSE, maximization performed. iteration_limit (integer(1) Inf) maximum number iterations parameter partition alternating optimization process terminated. Can also Inf iteration limit. seconds_limit (numeric(1)) time limit seconds alternating optimization process terminated. Can also Inf time limit. Note stopping criteria checked sub-problem solved within solving sub-problem, actual process time can exceed limit. tolerance_value (numeric(1)) non-negative tolerance value. alternating optimization terminates absolute difference current function value one tolerance_history iterations smaller tolerance_value. Can 0 value threshold. tolerance_parameter (numeric(1)) non-negative tolerance value. alternating optimization terminates distance current estimate tolerance_history iterations smaller tolerance_parameter. Can 0 parameter threshold. default, distance measured using euclidean norm, another norm can specified via tolerance_parameter_norm field. tolerance_parameter_norm (function) norm measures distance current estimate one last iteration. distance smaller tolerance_parameter, procedure terminated. must form function(x, y) two vector inputs x y, return single numeric value. default, euclidean norm function(x, y) sqrt(sum((x - y)^2)) used. tolerance_history (integer(1)) number iterations look back determine whether tolerance_value tolerance_parameter reached. iteration (integer(1)) current iteration number. block (integer()) currently active parameter block, represented parameter indices. output (list(), read-) output alternating optimization procedure, list following elements: estimate parameter vector termination. value function value termination. details data.frame full information procedure: iteration (column iteration) contains function value (column value), parameter values (columns starting p followed parameter index), active parameter block (columns starting b followed parameter index, 1 stands parameter contained active parameter block 0 ), computation times seconds (column seconds) seconds overall computation time seconds. stopping_reason message procedure terminated.","code":""},{"path":[]},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Procedure Object — Procedure","text":"Procedure$new() Procedure$print_status() Procedure$initialize_details() Procedure$update_details() Procedure$get_partition() Procedure$get_details() Procedure$get_value() Procedure$get_value_latest() Procedure$get_value_best() Procedure$get_parameter() Procedure$get_parameter_latest() Procedure$get_parameter_best() Procedure$get_seconds() Procedure$get_seconds_total() Procedure$check_stopping()","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Procedure Object — Procedure","text":"Creates new object R6 class.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$new(   npar = integer(),   partition = \"sequential\",   new_block_probability = 0.3,   minimum_block_number = 2,   verbose = FALSE,   minimize = TRUE,   iteration_limit = Inf,   seconds_limit = Inf,   tolerance_value = 1e-06,   tolerance_parameter = 1e-06,   tolerance_parameter_norm = function(x, y) sqrt(sum((x - y)^2)),   tolerance_history = 1 )"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Procedure Object — Procedure","text":"npar (integer(1)) (total) length target argument(s). partition (character(1) list()) Defines parameter partition, can either \"sequential\" treating parameter separately, \"random\" random partition iteration, \"none\" partition (equivalent joint optimization), list vectors parameter indices, specifying custom partition alternating optimization process. new_block_probability (numeric(1)) relevant partition = \"random\". probability new parameter block creating random partitions. Values close 0 result larger parameter blocks, values close 1 result smaller parameter blocks. minimum_block_number (integer(1)) relevant partition = \"random\". minimum number blocks random partitions. verbose (logical(1)) Whether print tracing details alternating optimization process. minimize (logical(1)) Whether minimize alternating optimization process. FALSE, maximization performed. iteration_limit (integer(1) Inf) maximum number iterations parameter partition alternating optimization process terminated. Can also Inf iteration limit. seconds_limit (numeric(1)) time limit seconds alternating optimization process terminated. Can also Inf time limit. Note stopping criteria checked sub-problem solved within solving sub-problem, actual process time can exceed limit. tolerance_value (numeric(1)) non-negative tolerance value. alternating optimization terminates absolute difference current function value one tolerance_history iterations smaller tolerance_value. Can 0 value threshold. tolerance_parameter (numeric(1)) non-negative tolerance value. alternating optimization terminates distance current estimate tolerance_history iterations smaller tolerance_parameter. Can 0 parameter threshold. default, distance measured using euclidean norm, another norm can specified via tolerance_parameter_norm field. tolerance_parameter_norm (function) norm measures distance current estimate one last iteration. distance smaller tolerance_parameter, procedure terminated. must form function(x, y) two vector inputs x y, return single numeric value. default, euclidean norm function(x, y) sqrt(sum((x - y)^2)) used. tolerance_history (integer(1)) number iterations look back determine whether tolerance_value tolerance_parameter reached.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-print-status-","dir":"Reference","previous_headings":"","what":"Method print_status()","title":"Procedure Object — Procedure","text":"Prints status message.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$print_status(message, message_type = 8, verbose = self$verbose)"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Procedure Object — Procedure","text":"message (character(1)) status message. message_type (integer(1)) type message, one following: 1 cli::cli_h1() 2 cli::cli_h2() 3 cli::cli_h3() 4 cli::cli_alert_success() 5 cli::cli_alert_info() 6 cli::cli_alert_warning() 7 cli::cli_alert_danger() 8 cli::cat_line() verbose (logical(1)) Whether print tracing details alternating optimization process.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-initialize-details-","dir":"Reference","previous_headings":"","what":"Method initialize_details()","title":"Procedure Object — Procedure","text":"Initializes details part output.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$initialize_details(initial_parameter, initial_value)"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Procedure Object — Procedure","text":"initial_parameter (numeric()) starting parameter values procedure. initial_value (numeric(1)) function value initial parameters.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-update-details-","dir":"Reference","previous_headings":"","what":"Method update_details()","title":"Procedure Object — Procedure","text":"Updates details part output.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$update_details(   value,   parameter_block,   seconds,   error,   block = self$block )"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Procedure Object — Procedure","text":"value (numeric(1)) updated function value. parameter_block (numeric()) updated parameter values active parameter block. seconds (numeric(1)) time seconds solving sub-problem. error (logical(1)) Whether solving sub-problem resulted error. block (integer()) currently active parameter block, represented parameter indices.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-get-partition-","dir":"Reference","previous_headings":"","what":"Method get_partition()","title":"Procedure Object — Procedure","text":"Get parameter partition.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$get_partition()"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-get-details-","dir":"Reference","previous_headings":"","what":"Method get_details()","title":"Procedure Object — Procedure","text":"Get details part output.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$get_details(   which_iteration = NULL,   which_block = NULL,   which_column = c(\"iteration\", \"value\", \"parameter\", \"block\", \"seconds\") )"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Procedure Object — Procedure","text":"which_iteration (integer()) Selects iteration(s). Can also NULL select iterations. which_block (character(1) integer()) Selects parameter block partition can one \"first\" first parameter block, \"last\" last parameter block, integer vector parameter indices, NULL parameter blocks. which_column (character()) Selects columns details part output can one \"iteration\", \"value\", \"parameter\", \"block\", \"seconds\"","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-get-value-","dir":"Reference","previous_headings":"","what":"Method get_value()","title":"Procedure Object — Procedure","text":"Get function value different steps alternating optimization procedure.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$get_value(   which_iteration = NULL,   which_block = NULL,   keep_iteration_column = FALSE,   keep_block_columns = FALSE )"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Procedure Object — Procedure","text":"which_iteration (integer()) Selects iteration(s). Can also NULL select iterations. which_block (character(1) integer()) Selects parameter block partition can one \"first\" first parameter block, \"last\" last parameter block, integer vector parameter indices, NULL parameter blocks. keep_iteration_column (logical()) Whether keep column containing information iteration output. keep_block_columns (logical()) Whether keep column containing information active parameter block output.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-get-value-latest-","dir":"Reference","previous_headings":"","what":"Method get_value_latest()","title":"Procedure Object — Procedure","text":"Get function value latest step alternating optimization procedure.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$get_value_latest()"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-get-value-best-","dir":"Reference","previous_headings":"","what":"Method get_value_best()","title":"Procedure Object — Procedure","text":"Get optimum function value alternating optimization procedure.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$get_value_best()"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-get-parameter-","dir":"Reference","previous_headings":"","what":"Method get_parameter()","title":"Procedure Object — Procedure","text":"Get parameter values different steps alternating optimization procedure.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$get_parameter(   which_iteration = self$iteration,   which_block = NULL,   keep_iteration_column = FALSE,   keep_block_columns = FALSE )"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Procedure Object — Procedure","text":"which_iteration (integer()) Selects iteration(s). Can also NULL select iterations. which_block (character(1) integer()) Selects parameter block partition can one \"first\" first parameter block, \"last\" last parameter block, integer vector parameter indices, NULL parameter blocks. keep_iteration_column (logical()) Whether keep column containing information iteration output. keep_block_columns (logical()) Whether keep column containing information active parameter block output.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-get-parameter-latest-","dir":"Reference","previous_headings":"","what":"Method get_parameter_latest()","title":"Procedure Object — Procedure","text":"Get parameter value latest step alternating optimization procedure.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$get_parameter_latest(parameter_type = \"full\")"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Procedure Object — Procedure","text":"parameter_type (character(1)) Can one \"full\" (default) get full parameter vector, \"block\" get parameter values current block, .e., parameters indices self$block \"fixed\" get parameter values currently fixed, .e., except indices self$block","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-get-parameter-best-","dir":"Reference","previous_headings":"","what":"Method get_parameter_best()","title":"Procedure Object — Procedure","text":"Get optimum parameter value alternating optimization procedure.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$get_parameter_best(parameter_type = \"full\")"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Procedure Object — Procedure","text":"parameter_type (character(1)) Can one \"full\" (default) get full parameter vector, \"block\" get parameter values current block, .e., parameters indices self$block \"fixed\" get parameter values currently fixed, .e., except indices self$block","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-get-seconds-","dir":"Reference","previous_headings":"","what":"Method get_seconds()","title":"Procedure Object — Procedure","text":"Get optimization time seconds different steps alternating optimization procedure.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$get_seconds(   which_iteration = NULL,   which_block = NULL,   keep_iteration_column = FALSE,   keep_block_columns = FALSE )"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Procedure Object — Procedure","text":"which_iteration (integer()) Selects iteration(s). Can also NULL select iterations. which_block (character(1) integer()) Selects parameter block partition can one \"first\" first parameter block, \"last\" last parameter block, integer vector parameter indices, NULL parameter blocks. keep_iteration_column (logical()) Whether keep column containing information iteration output. keep_block_columns (logical()) Whether keep column containing information active parameter block output.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-get-seconds-total-","dir":"Reference","previous_headings":"","what":"Method get_seconds_total()","title":"Procedure Object — Procedure","text":"Get total optimization time seconds alternating optimization procedure.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$get_seconds_total()"},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"method-check-stopping-","dir":"Reference","previous_headings":"","what":"Method check_stopping()","title":"Procedure Object — Procedure","text":"Checks alternating optimization procedure can terminated.","code":""},{"path":"https://loelschlaeger.de/ao/reference/Procedure.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Procedure Object — Procedure","text":"","code":"Procedure$check_stopping()"},{"path":"https://loelschlaeger.de/ao/reference/ao-package.html","id":null,"dir":"Reference","previous_headings":"","what":"ao: Alternating Optimization — ao-package","title":"ao: Alternating Optimization — ao-package","text":"Alternating optimization iterative procedure optimizes function alternately performing restricted optimization individual parameter subsets. Instead tackling joint optimization directly, breaks problem simpler sub-problems. approach can make optimization feasible joint optimization difficult.","code":""},{"path":[]},{"path":"https://loelschlaeger.de/ao/reference/ao-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ao: Alternating Optimization — ao-package","text":"Maintainer: Lennart Oelschläger oelschlaeger.lennart@gmail.com (ORCID) contributors: Siddhartha Chib chib@wustl.edu [contributor]","code":""},{"path":"https://loelschlaeger.de/ao/reference/ao.html","id":null,"dir":"Reference","previous_headings":"","what":"Alternating Optimization — ao","title":"Alternating Optimization — ao","text":"Alternating optimization iterative procedure optimizing real-valued function jointly parameters alternating restricted optimization parameter partitions.","code":""},{"path":"https://loelschlaeger.de/ao/reference/ao.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alternating Optimization — ao","text":"","code":"ao(   f,   initial,   target = NULL,   npar = NULL,   gradient = NULL,   ...,   partition = \"sequential\",   new_block_probability = 0.3,   minimum_block_number = 2,   minimize = TRUE,   lower = -Inf,   upper = Inf,   iteration_limit = Inf,   seconds_limit = Inf,   tolerance_value = 1e-06,   tolerance_parameter = 1e-06,   tolerance_parameter_norm = function(x, y) sqrt(sum((x - y)^2)),   tolerance_history = 1,   base_optimizer = Optimizer$new(\"stats::optim\", method = \"L-BFGS-B\"),   verbose = FALSE,   hide_warnings = TRUE )"},{"path":"https://loelschlaeger.de/ao/reference/ao.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alternating Optimization — ao","text":"f (function) function optimized, returning single numeric value. first argument f numeric length initial, optionally followed arguments specified ... argument. f optimized argument first, one argument, specified via target argument. initial (numeric() list()) starting parameter values target argument(s). can also list multiple starting parameter values, see details. target (character() NULL) name(s) argument(s) f gets optimized. can numeric arguments. Can NULL (default), first argument f. npar (integer()) length target argument(s). Must specified two target arguments specified via target argument. Can NULL one target argument, case npar set length(initial). gradient (function NULL) function returns gradient f. function call gradient must identical f. Can NULL, case finite-difference approximation used. ... Additional arguments passed f (gradient). partition (character(1) list()) Defines parameter partition, can either \"sequential\" treating parameter separately, \"random\" random partition iteration, \"none\" partition (equivalent joint optimization), list vectors parameter indices, specifying custom partition alternating optimization process. can also list multiple partition definitions, see details. new_block_probability (numeric(1)) relevant partition = \"random\". probability new parameter block creating random partitions. Values close 0 result larger parameter blocks, values close 1 result smaller parameter blocks. minimum_block_number (integer(1)) relevant partition = \"random\". minimum number blocks random partitions. minimize (logical(1)) Whether minimize alternating optimization process. FALSE, maximization performed. lower, upper (numeric()) Optionally lower upper parameter bounds. iteration_limit (integer(1) Inf) maximum number iterations parameter partition alternating optimization process terminated. Can also Inf iteration limit. seconds_limit (numeric(1)) time limit seconds alternating optimization process terminated. Can also Inf time limit. Note stopping criteria checked sub-problem solved within solving sub-problem, actual process time can exceed limit. tolerance_value (numeric(1)) non-negative tolerance value. alternating optimization terminates absolute difference current function value one tolerance_history iterations smaller tolerance_value. Can 0 value threshold. tolerance_parameter (numeric(1)) non-negative tolerance value. alternating optimization terminates distance current estimate tolerance_history iterations smaller tolerance_parameter. Can 0 parameter threshold. default, distance measured using euclidean norm, another norm can specified via tolerance_parameter_norm argument. tolerance_parameter_norm (function) norm measures distance current estimate one last iteration. distance smaller tolerance_parameter, procedure terminated. must form function(x, y) two vector inputs x y, return single numeric value. default, euclidean norm function(x, y) sqrt(sum((x - y)^2)) used. tolerance_history (integer(1)) number iterations look back determine whether tolerance_value tolerance_parameter reached. base_optimizer (Optimizer list()) Optimizer object, can created via Optimizer. numerically solves sub-problems. default, optim optimizer used. another optimizer specified, arguments gradient, lower, upper ignored. can also list multiple base optimizers, see details. verbose (logical(1)) Whether print tracing details alternating optimization process. hide_warnings (logical(1)) Whether hide warnings alternating optimization process.","code":""},{"path":"https://loelschlaeger.de/ao/reference/ao.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alternating Optimization — ao","text":"list following elements: estimate parameter vector termination. value function value termination. details data.frame full information procedure: iteration (column iteration) contains function value (column value), parameter values (columns starting p followed parameter index), active parameter block (columns starting b followed parameter index, 1 stands parameter contained active parameter block 0 ), computation times seconds (column seconds) seconds overall computation time seconds. stopping_reason message procedure terminated. case multiple threads, output changes slightly, see details.","code":""},{"path":[]},{"path":"https://loelschlaeger.de/ao/reference/ao.html","id":"multiple-threads","dir":"Reference","previous_headings":"","what":"Multiple threads","title":"Alternating Optimization — ao","text":"Alternating optimization can suffer local optima. increase likelihood reaching global optimum, can specify: multiple starting parameters multiple parameter partitions multiple base optimizers Use initial, partition, /base_optimizer arguments provide list possible values parameter. combination initial values, parameter partitions, base optimizers create separate alternating optimization thread.","code":""},{"path":"https://loelschlaeger.de/ao/reference/ao.html","id":"output-value","dir":"Reference","previous_headings":"","what":"Output value","title":"Alternating Optimization — ao","text":"case multiple threads, output changes slightly comparison standard case. still list following elements: estimate optimal parameter vector threads. value optimal function value threads. details combines details single threads additional column thread index different threads. seconds gives computation time seconds thread. stopping_reason gives termination message thread. threads give details different threads specified.","code":""},{"path":"https://loelschlaeger.de/ao/reference/ao.html","id":"parallel-computation","dir":"Reference","previous_headings":"","what":"Parallel computation","title":"Alternating Optimization — ao","text":"default, threads run sequentially. However, since independent, can parallelized. enable parallel computation, use {future} framework. example, run following ao() call:","code":"future::plan(future::multisession, workers = 4)"},{"path":"https://loelschlaeger.de/ao/reference/ao.html","id":"progress-updates","dir":"Reference","previous_headings":"","what":"Progress updates","title":"Alternating Optimization — ao","text":"using multiple threads, setting verbose = TRUE print tracing details alternating optimization supported. However, can still track progress threads using {progressr} framework. example, run following ao() call:","code":"progressr::handlers(global = TRUE) progressr::handlers(   progressr::handler_progress(\":percent :eta :message\") )"},{"path":"https://loelschlaeger.de/ao/reference/ao.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Alternating Optimization — ao","text":"","code":"# Example 1: Minimization of Himmelblau's function --------------------------  himmelblau <- function(x) (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2 ao(f = himmelblau, initial = c(0, 0)) #> $estimate #> [1]  3.584428 -1.848126 #>  #> $value #> [1] 9.606386e-12 #>  #> $details #>    iteration        value       p1        p2 b1 b2     seconds #> 1          0 1.700000e+02 0.000000  0.000000  0  0 0.000000000 #> 2          1 1.327270e+01 3.395691  0.000000  1  0 0.018218040 #> 3          1 1.743664e+00 3.395691 -1.803183  0  1 0.003746748 #> 4          2 2.847290e-02 3.581412 -1.803183  1  0 0.003023863 #> 5          2 4.687468e-04 3.581412 -1.847412  0  1 0.002662897 #> 6          3 7.368057e-06 3.584381 -1.847412  1  0 0.002151489 #> 7          3 1.164202e-07 3.584381 -1.848115  0  1 0.017347097 #> 8          4 1.893311e-09 3.584427 -1.848115  1  0 0.001780987 #> 9          4 9.153860e-11 3.584427 -1.848124  0  1 0.001392365 #> 10         5 6.347425e-11 3.584428 -1.848124  1  0 0.001437426 #> 11         5 9.606386e-12 3.584428 -1.848126  0  1 0.001444101 #>  #> $seconds #> [1] 0.05320501 #>  #> $stopping_reason #> [1] \"change in function value between 1 iteration is < 1e-06\" #>   # Example 2: Maximization of 2-class Gaussian mixture log-likelihood --------  # target arguments: # - class means mu (2, unrestricted) # - class standard deviations sd (2, must be non-negative) # - class proportion lambda (only 1 for identification, must be in [0, 1])  normal_mixture_llk <- function(mu, sd, lambda, data) {   c1 <- lambda * dnorm(data, mu[1], sd[1])   c2 <- (1 - lambda) * dnorm(data, mu[2], sd[2])   sum(log(c1 + c2)) }  ao(   f = normal_mixture_llk,   initial = c(2, 4, 1, 1, 0.5),   target = c(\"mu\", \"sd\", \"lambda\"),   npar = c(2, 2, 1),   data = datasets::faithful$eruptions,   partition = \"random\",   minimize = FALSE,   lower = c(-Inf, -Inf, 0, 0, 0),   upper = c(Inf, Inf, Inf, Inf, 1) ) #> $estimate #> [1] 2.0186090 4.2733464 0.2356276 0.4370607 0.3484060 #>  #> $value #> [1] -276.36 #>  #> $details #>    iteration     value       p1       p2        p3        p4        p5 b1 b2 b3 #> 1          0 -431.7364 2.000000 4.000000 1.0000000 1.0000000 0.5000000  0  0  0 #> 2          1 -431.7364 2.000000 4.000000 1.0000000 1.0000000 0.5000000  0  0  1 #> 3          1 -431.7364 2.000000 4.000000 1.0000000 1.0000000 0.5000000  0  0  0 #> 4          1 -418.3965 2.793604 4.000000 1.0000000 1.0000000 0.5000000  1  0  0 #> 5          1 -417.3246 2.793604 4.154130 1.0000000 1.0000000 0.5000000  0  1  0 #> 6          2 -359.0143 2.258795 4.154130 1.0000000 0.4177621 0.4048863  1  0  0 #> 7          2 -302.9759 2.258795 4.299899 0.3607804 0.4177621 0.4048863  0  1  1 #> 8          3 -301.8925 2.258795 4.298972 0.3587102 0.4177621 0.3610747  0  1  1 #> 9          3 -284.7084 2.043457 4.298972 0.3587102 0.4062419 0.3610747  1  0  0 #> 10         4 -284.7039 2.043457 4.298972 0.3587102 0.4063022 0.3582760  0  0  0 #> 11         4 -277.0461 2.026726 4.280867 0.2484361 0.4063022 0.3582760  1  1  1 #> 12         5 -277.0461 2.026725 4.280867 0.2484361 0.4063022 0.3582760  1  1  0 #> 13         5 -276.4251 2.026725 4.280867 0.2384333 0.4346806 0.3491353  0  0  1 #> 14         6 -276.3672 2.019415 4.274101 0.2384333 0.4359301 0.3487486  1  1  0 #> 15         6 -276.3613 2.019415 4.274101 0.2361126 0.4359301 0.3487486  0  0  1 #> 16         7 -276.3603 2.018681 4.274101 0.2357403 0.4369592 0.3487486  1  0  1 #> 17         7 -276.3601 2.018681 4.273383 0.2357403 0.4369592 0.3484232  0  1  0 #> 18         8 -276.3601 2.018681 4.273378 0.2356660 0.4369592 0.3484232  0  1  1 #> 19         8 -276.3600 2.018620 4.273378 0.2356660 0.4370453 0.3484118  1  0  0 #> 20         9 -276.3600 2.018622 4.273356 0.2356660 0.4370453 0.3484118  1  1  0 #> 21         9 -276.3600 2.018622 4.273356 0.2356309 0.4370545 0.3484092  0  0  1 #> 22        10 -276.3600 2.018622 4.273349 0.2356312 0.4370610 0.3484068  0  1  1 #> 23        10 -276.3600 2.018613 4.273349 0.2356312 0.4370610 0.3484068  1  0  0 #> 24        11 -276.3600 2.018613 4.273349 0.2356276 0.4370607 0.3484068  0  0  1 #> 25        11 -276.3600 2.018609 4.273346 0.2356276 0.4370607 0.3484060  1  1  0 #>    b4 b5     seconds #> 1   0  0 0.000000000 #> 2   0  1          NA #> 3   1  0          NA #> 4   0  0 0.003369570 #> 5   0  0 0.002859354 #> 6   1  1 0.015780210 #> 7   0  0 0.016301155 #> 8   0  1 0.008395433 #> 9   1  0 0.006133080 #> 10  1  1 0.014087200 #> 11  0  0 0.010613918 #> 12  0  0 0.002734423 #> 13  1  1 0.010541201 #> 14  1  1 0.011978626 #> 15  0  0 0.003162384 #> 16  1  0 0.007127762 #> 17  0  1 0.005183220 #> 18  0  0 0.004416466 #> 19  1  1 0.004977465 #> 20  0  0 0.002680063 #> 21  1  1 0.004911184 #> 22  1  1 0.004926682 #> 23  0  0 0.001799583 #> 24  1  0 0.002946615 #> 25  0  1 0.003875732 #>  #> $seconds #> [1] 0.1488013 #>  #> $stopping_reason #> [1] \"change in function value between 1 iteration is < 1e-06\" #>"},{"path":"https://loelschlaeger.de/ao/reference/ao_input_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Input checks — ao_input_check","title":"Input checks — ao_input_check","text":"helper function checks inputs ao function.","code":""},{"path":"https://loelschlaeger.de/ao/reference/ao_input_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Input checks — ao_input_check","text":"","code":"ao_input_check(   argument_name,   check_result,   error_message = check_result,   prefix = \"Input {.var {argument_name}} is bad:\" )"},{"path":"https://loelschlaeger.de/ao/reference/ao_input_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Input checks — ao_input_check","text":"argument_name (character(1)) name argument checked. check_result (logical(1))TRUE check successful. error_message (character(1)) error message printed. prefix (character(1)) prefix error message.","code":""},{"path":"https://loelschlaeger.de/ao/reference/ao_input_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Input checks — ao_input_check","text":"Either throws error, invisible TRUE.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-110","dir":"Changelog","previous_headings":"","what":"ao 1.1.0","title":"ao 1.1.0","text":"Alternating optimization can now run multiple (possibly parallel) threads providing list values initial, partition, /base_optimizer parameters, combination creates separate alternating optimization thread.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-101","dir":"Changelog","previous_headings":"","what":"ao 1.0.1","title":"ao 1.0.1","text":"Removed update_code output. Updates now accepted regardless whether improve function value. end, best solution returned. Added tolerance_history argument compare function value parameters one iteration. Added hide_warnings argument hide warnings AO procedure.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-100","dir":"Changelog","previous_headings":"","what":"ao 1.0.0","title":"ao 1.0.0","text":"CRAN release: 2024-06-20 Implemented random partitions, parameter bounds, new stopping criteria (iteration limit, time limit, change function value, change parameters). ao() API change lot, please check documentation.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-033","dir":"Changelog","previous_headings":"","what":"ao 0.3.3","title":"ao 0.3.3","text":"CRAN release: 2024-02-29 Now using cli improve error messages.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-032","dir":"Changelog","previous_headings":"","what":"ao 0.3.2","title":"ao 0.3.2","text":"CRAN release: 2024-02-05 Fixed #4 (thanks S. Chib).","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-031","dir":"Changelog","previous_headings":"","what":"ao 0.3.1","title":"ao 0.3.1","text":"CRAN release: 2024-01-31 Added package start -message. Added details README file. Increased required version optimizeR version 1.0.3.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-030","dir":"Changelog","previous_headings":"","what":"ao 0.3.0","title":"ao 0.3.0","text":"CRAN release: 2023-11-08 Updated code new optimizeR version 1.0.1.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-027","dir":"Changelog","previous_headings":"","what":"ao 0.2.7","title":"ao 0.2.7","text":"CRAN release: 2023-09-29 Renamed input print.level -> verbose. return value, renamed element \"time\" -> \"seconds\" (time now always seconds); \"sequence\" element. Additionally, added \"value\" column \"sequence\" element. Added input f_partition optionally specify functions partitions. Added input joint_end optionally optimize jointly end alternating optimization procedure. Input iterlim can Inf now. empty elements partition longer allowed. Removed plotting feature parameter updates estimation. New dependency checkmate input checks.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-026","dir":"Changelog","previous_headings":"","what":"ao 0.2.6","title":"ao 0.2.6","text":"CRAN release: 2023-03-31 Added package logo created package website (https://loelschlaeger.de/ao/) {pkgdown} package. code changes.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-025","dir":"Changelog","previous_headings":"","what":"ao 0.2.5","title":"ao 0.2.5","text":"CRAN release: 2023-01-23 Updated code new optimizeR version 0.3.0, renamed changed input output names. particular, ao(), renamed input optimizer -> base_optimizer. Fixed bug using numerical gradient /Hessian target function.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-024","dir":"Changelog","previous_headings":"","what":"ao 0.2.4","title":"ao 0.2.4","text":"CRAN release: 2022-12-04 Updated code new optimizeR version 0.2.0, renamed functions.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-023","dir":"Changelog","previous_headings":"","what":"ao 0.2.3","title":"ao 0.2.3","text":"CRAN release: 2022-09-02 Fixed bugs ... arguments ao().","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-022","dir":"Changelog","previous_headings":"","what":"ao 0.2.2","title":"ao 0.2.2","text":"CRAN release: 2022-08-24 Removed set_f() interface. optimization problem now specified directly ao(). output format ao() changed, see documentation ao(). Arbitrary optimizer can now specified ao() optimizer object via framework {optimizeR} package. Removed utils functions ao. imported optimizeR package.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-021","dir":"Changelog","previous_headings":"","what":"ao 0.2.1","title":"ao 0.2.1","text":"CRAN release: 2022-01-04 Himmelblau’s function included example.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-020","dir":"Changelog","previous_headings":"","what":"ao 0.2.0","title":"ao 0.2.0","text":"ao() now returns sequence estimates different iterations data frame. ao() now able plot sequence estimates estimation. Argument groups ao() now called partition sequence replaced iterations. New function set_f() specification optimization problem. Parameter constraints can now imposed target function. New helper functions is_number(), try_silent(), timed() euclidean(). Included vignette details alternating optimization. New package sticker.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-014","dir":"Changelog","previous_headings":"","what":"ao 0.1.4","title":"ao 0.1.4","text":"CRAN release: 2021-10-06 Updated package metadata. Updated package sticker.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-013","dir":"Changelog","previous_headings":"","what":"ao 0.1.3","title":"ao 0.1.3","text":"CRAN release: 2021-08-12 Exported method print.ao().","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-012","dir":"Changelog","previous_headings":"","what":"ao 0.1.2","title":"ao 0.1.2","text":"CRAN release: 2021-08-10 Skip alternation optimization step group empty. Estimation times now returned always seconds. Return stats::nlm() outputs. Implemented method print.ao().","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-011","dir":"Changelog","previous_headings":"","what":"ao 0.1.1","title":"ao 0.1.1","text":"CRAN release: 2021-06-30 Fixed minor bugs.","code":""},{"path":"https://loelschlaeger.de/ao/news/index.html","id":"ao-010","dir":"Changelog","previous_headings":"","what":"ao 0.1.0","title":"ao 0.1.0","text":"CRAN release: 2021-06-21 Initial release.","code":""}]
