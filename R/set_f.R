#' Specify optimization problem
#'
#' @description
#' This function specifies the function to be optimized.
#'
#' @param f
#' A function to be optimized, returning a single numeric value.
#' Its first argument should be a numeric vector of length \code{npar}.
#' Additional arguments can be specified via the \code{...} argument.
#' Gradient or Hessian of \code{f} can be specified via attributes
#' \code{gradient} and \code{hessian} for the function value.
#' They are used for optimization if specified.
#' @param ...
#' Additional arguments to be passed to \code{f}.
#' @param npar
#' The number of variables of \code{f}.
#' @param lower
#' Lower bounds on the variables, which can be a single numeric value
#' (a joint bound for all parameters) or a numeric vector of length \code{npar}
#' (for individual bounds).
#' @param upper
#' Upper bounds on the variables, analogue to \code{lower}.
#' @param check
#' If \code{TRUE} checks the configuration.
#' This generally takes at most 20 seconds.
#' Set to \code{FALSE} if you are confident about the configuration to save
#' computation time.
#' @param optimizer
#' The default optimizer is \code{\link[stats]{optim}}.
#' Optionally, specify an object \code{optimizer} (which can be generated by
#' \code{\link[ino]{set_optimizer}}) for a custom optimizer. The arguments
#' \code{lower} and \code{upper} are not passed to a custom optimizer.
#'
#' @return
#' An object of class \code{ao_f}.
#'
#' @export
#'
#' @examples
#' ### function to be optimized
#' himmelblau <- function(x) (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2
#'
#' ### standard optimizer
#' set_f(f = himmelblau, npar = 2, lower = c(-5,-5), upper = c(5,5), check = TRUE)
#'
#' ### custom optimizer
#' custom_opt <- ino::set_optimizer(
#'   opt = pracma::nelder_mead, f = "fn",
#'   p = "x0", v = "fmin", z = "xmin", tol = 1e-6,
#'   crit = c("xmin", "fcount")
#' )
#' set_f(f = himmelblau, npar = 2, optimizer = custom_opt)

set_f <- function(f, ..., npar, lower = -Inf, upper = Inf, check = FALSE,
                  optimizer = NULL) {

  ### input checks
  if (missing(f)) {
    stop("Please set 'f'.",
         call. = FALSE)
  }
  if (!is.function(f)) {
    stop("'f' must be a function.",
         call. = FALSE)
  }
  if (missing(npar)) {
    stop("Please set 'npar'.",
         call. = FALSE)
  }
  if (!(length(npar) == 1 && is_number(npar))) {
    stop("'npar' must be a number.",
         call. = FALSE)
  }
  if (is.null(optimizer)) {
    if (!is.numeric(lower)) {
      stop("'lower' must be numeric.",
           call. = FALSE)
    }
    if (length(lower) == 1) {
      lower <- rep(lower, npar)
    }
    if (length(lower) != npar) {
      stop("'lower' must be of length 1 or 'npar'.",
           call. = FALSE)
    }
    if (!is.numeric(upper)) {
      stop("'upper' must be numeric.",
           call. = FALSE)
    }
    if (length(upper) == 1) {
      upper <- rep(upper, npar)
    }
    if (length(upper) != npar) {
      stop("'upper' must be of length 1 or 'npar'.",
           call. = FALSE)
    }
    if (any(upper < lower)) {
      stop("(Each element of) 'upper' must be greater than 'lower'.",
           call. = FALSE)
    }
    optimizer <- ino::set_optimizer_optim("lower" = lower, "upper" = upper)
  }
  if (!inherits(optimizer, "optimizer")) {
    stop("'optimizer' must be generated by 'ino::set_optimizer()'.",
         call. = FALSE)
  }
  if (!is.logical(check)) {
    stop("'stop' must be a boolean.", call. = FALSE)
  }
  f_par <- list(...)

  ### configuration checks
  if (check) {
    check_runs <- 10
    f_success <- 0
    optimizer_success <- 0
    first_fail <- NULL
    for (i in 1:check_runs) {
      if (any(lower != -Inf) || any(upper != Inf)) {
        p <- stats::runif(npar, lower, upper)
      } else {
        p <- stats::rnorm(npar)
      }
      out_f <- timed(try_silent(f(p)), 1)
      if (inherits(out_f, "fail")) {
        if (is.null(first_fail)) {
          first_fail <- out_f
        }
        next
      } else {
        f_success <- f_success + 1
        base_args <- list(f, p)
        names(base_args) <- optimizer$base_arg_names[1:2]
        out_optimizer <- timed(
          expr = try_silent(do.call(
            what = optimizer$f,
            args = c(base_args, f_par, optimizer$args)
          )),
          secs = 1)
        if (inherits(out_optimizer, "fail")) {
          if (is.null(first_fail)) {
            first_fail <- out_optimizer
          }
          next
        } else {
          optimizer_success <- optimizer_success + 1
        }
      }
    }
    if (f_success == 0 || optimizer_success == 0) {
      stop("Check failed.\n First error was: ", first_fail, call. = FALSE)
    } else if (f_success < check_runs || optimizer_success < check_runs) {
      warning(
        check_runs - f_success, " of ", check_runs,
        " random calls of 'f' failed. ", check_runs - optimizer_success, " of ",
        check_runs, " calls of 'optimizer' failed.\n",
        "First error was: ", first_fail,
        call. = FALSE
      )
    } else {
      message("Configuration checked.")
    }
  }

  ### output
  out <- list("f" = f, "npar" = npar, "f_par" = f_par, "lower" = lower,
              "upper" = upper, "optimizer" = optimizer)
  class(out) <- "ao_f"
  return(out)
}

#' @exportS3Method
#' @noRd

print.ao_f <- function(x, ...) {
  cat("<ao_f>")
}
