---
title: "Alternating optimization with {ao}"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Alternating optimization with {ao}}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ref.bib
link-citations: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Background

### What is alternating optimization?

Alternating optimization is an iterative procedure for optimizing some function jointly over all parameters by alternating restricted optimization over individual parameter subsets.

More precisely, consider minimizing or maximizing $f:\mathbb{R}^n \to \mathbb{R}$ over the set of feasible points $x \in X \subseteq \mathbb{R}^n$. The underlying algorithm of alternating optimization is as follows:

1. Assign an initial value for $x$.

2. Optimize $f$ with respect to a subset of parameters $\tilde{x}$ while holding the other parameters constant. (Note that alternating optimization is a generalization of joint optimization, where the only parameter subset would be the whole set of parameters.)

3. Replace the values in $x$ by the optimal values for $\tilde{x}$ found in step 2.

4. Repeat from step 2 with another parameter subset.

5. Stop when the process has converged or reached an iteration limit.

### When is alternating optimization a good idea?

- When the joint optimization is (numerically) difficult (or not feasible).

- When there is a natural division of the parameters. That is the case, e.g., for likelihood functions, where the parameter space naturally divides into parameter subsets corresponding to linear effects, variances and covariances with different influence on the likelihood value.

- To improve optimization time in some cases, see [@hu:2002] for an example.

- Compared to joint optimization, alternating optimization may be better in bypassing local optima, see [@bezdek:2002].

### What are the properties of alternating optimization?

Alternating optimization (under certain conditions on $f$) can convergence to the global optimum. However, the set of possible solutions also contains saddle points [@bezdek:1987].

@bezdek:2003 shows that alternating optimization under reasonable assumptions is locally $q$-linearly convergent.

## Application

As an application, we consider minimizing the [Himmelblau's function](https://en.wikipedia.org/wiki/Himmelblau%27s_function) in $n = 2$ dimensions with parameter constraints $-5 \leq x_1, x_2 \leq 5$:

```{r ao}
library("ao")
himmelblau <- function(x) (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2
ao(f = himmelblau, p = c(0,0), partition = list(1, 2),
   optimizer = optimizer_optim(lower = -5, upper = 5, method = "L-BFGS-B"))
```

The call minimizes `f` by alternating optimizing with respect to each parameter separately, where the parameters all are initialized at the value 0. 

The `ao()` function has the following arguments:

* `f`: The function to be optimized, returning a single numeric value. The first argument of `f` must be a numeric vector of the length of `p` followed by any other arguments specified by the `...` argument.
* `p`: Starting parameter values for the optimization.
* `...`: Additional arguments to be passed to `f`.
* `partition`: A list of vectors of indices of `p`, specifying the partition of the alternating optimization. The default is `as.list(1:length(p))`, i.e. each parameter is optimized separately. Parameter indices can be members of multiple subsets.
* `optimizer`:  An object of class `optimizer`, which can be specified via `optimizeR::set_optimizer()`. The default optimizer is `stats::optim()`.
* `iterations`: The number of iterations through the partitions. The default is `10`.
* `tolerance`: A non-negative numeric value. The function terminates prematurely if the euclidean distance between the current solution and the one from the last iteration is smaller than `tolerance`. The default is `1e-6`.
* `print.level`: This argument determines the level of printing which is done during the
optimization process. Three values (analogue to `stats::nlm()`) can be specified:
  * `0` (the default): no printing
  * `1`: initial and final details are printed
  * `2`: full tracing information is printed
* `plot`: If `TRUE`, the parameter updates are plotted. The default is `FALSE`.

## References
