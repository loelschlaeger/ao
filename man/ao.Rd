% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ao.R, R/ao_fixed.R, R/ao_random.R
\name{ao}
\alias{ao}
\alias{ao_fixed}
\alias{ao_random}
\title{Alternating Optimization}
\usage{
ao(
  objective,
  partition = Partition$new(npar = sum(objective$npar), type = "random"),
  optimizer = Optimizer$new("stats::optim"),
  initial = stats::rnorm(sum(objective$npar)),
  procedure = Procedure$new(verbose = TRUE, minimize = TRUE)
)

ao_fixed(
  f,
  initial,
  ...,
  fixed_partition = as.list(1:length(initial)),
  minimize = TRUE,
  iteration_limit = Inf,
  tolerance_value = 1e-06,
  verbose = FALSE
)

ao_random(
  f,
  initial,
  ...,
  new_block_probability = 0.3,
  minimum_block_number = 2,
  minimize = TRUE,
  iteration_limit = Inf,
  tolerance_value = 1e-06,
  verbose = FALSE
)
}
\arguments{
\item{objective}{(\code{Objective})\cr
The objective function to be optimized via alternating optimization.
Can be created via \code{\link[optimizeR]{Objective}}.}

\item{partition}{(\code{Partition})\cr
The parameter partition for alternating optimization.
Can be created via \code{\link{Partition}}.}

\item{optimizer}{(\code{Optimizer})\cr
The optimizer for solving the sub-problems.
Can be created via \code{\link[optimizeR]{Optimizer}}.}

\item{initial}{(\code{numeric()})\cr
The starting parameter values.}

\item{procedure}{(\code{Procedure})\cr
The alternating optimization procedure.
Can be created via \code{\link{Procedure}}.}

\item{f}{(\code{function})\cr
A \code{function} to be optimized, returning a single \code{numeric}.
The first argument of \code{f} must be a \code{numeric} of the same length as
\code{initial}, followed by any other arguments specified by the \code{...}
argument.}

\item{...}{Additional arguments to be passed to \code{f}.}

\item{fixed_partition}{(\code{list()})\cr
A \code{list} of vectors of indices of \code{initial}, specifying the
partition of the parameter vector in the alternating optimization process.
The default is \code{as.list(1:length(initial))}, i.e. each parameter is
optimized separately.}

\item{minimize}{(\code{logical(1)})\cr
Whether to minimize during the alternating optimization process.
If \code{FALSE}, maximization is performed.}

\item{iteration_limit}{(\code{integer(1)} or \code{Inf})\cr
The maximum number of iterations through the parameter partition before
the alternating optimization process is terminated.
Can also be \code{Inf} for no iteration limit.}

\item{tolerance_value}{(\code{numeric(1)})\cr
A non-negative tolerance value. The alternating optimization terminates
if the absolute difference between the current function value and the one
from the last iteration is smaller than \code{tolerance_value}.
Can be \code{0} for no value threshold.}

\item{new_block_probability}{(\code{numeric(1)})\cr
The probability for a new parameter block in random partitions.
Values close to 0 result in larger parameter blocks, values close to 1
result in smaller parameter blocks.}

\item{minimum_block_number}{(\code{integer(1)})\cr
The minimum number of blocks in random partitions.}
}
\value{
A \code{list} with the following elements:
\itemize{
\item \code{estimate} is the parameter vector at termination.
\item \code{value} is the function value at termination.
\item \code{details} is a \code{data.frame} with full information about the procedure:
For each iteration (column \code{iteration}) it contains the function value
(column \code{value}), parameter values (columns starting with \code{p} followed by
the parameter index), the active parameter block (columns starting with \code{b}
followed by the parameter index, where \code{1} stands for a parameter contained
in the active parameter block and \code{0} if not), computation times in seconds
(column \code{seconds}), and a code that summarizes whether the update got
accepted (column \code{update_code}, where \code{0} stands for an accepted update,
\code{1} for a rejected update due to an error when solving the sub-problem, and
\code{2} for a rejected update because it did not improve the function value).
\item \code{seconds} is the overall computation time in seconds.
\item \code{stopping_reason} is a message why the procedure has terminated.
}
}
\description{
Alternating optimization is an iterative procedure for optimizing a
real-valued function jointly over all its parameters by alternating
restricted optimization over parameter partitions.
\itemize{
\item \code{ao} is the most general API
\item \code{ao_fixed} is the special case of a parameter partition that remains fixed
during the alternating optimization procedure
\item \code{ao_random} is the special case of random partitions
}
}
\section{Fields}{

\describe{
\item{\code{verbose}}{(\code{logical(1)})\cr
Whether to print tracing details during the alternating optimization
process.}
}}

\examples{
# Example 1: Minimization of Himmelblau's function --------------------------

# see https://en.wikipedia.org/wiki/Himmelblau\%27s_function
himmelblau <- function(x) (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2

ao_fixed(
  f = himmelblau,
  initial = c(0, 0),              # initialization at the origin
  fixed_partition = as.list(1:2), # minimize one parameter cond. on the other
  tolerance_value = 1e-6,         # stop if objective value improvem. <= 1e-6
  verbose = FALSE
)

# Example 2: Maximization of 2-class Gaussian mixture log-likelihood --------

# targets:
# - class means mu (2, unrestricted)
# - class standard deviations sd (2, must be non-negative)
# - class proportion lambda (only 1 for identification, must be in [0, 1])
normal_mixture_llk <- function(mu, sd, lambda, data) {
  c1 <- lambda * dnorm(data, mu[1], sd[1])
  c2 <- (1 - lambda) * dnorm(data, mu[2], sd[2]))
  sum(log(c1 + c2))
}

# overview of the data set
hist(datasets::faithful$eruptions, breaks = 20)

# definition of the 'Objective' object
objective <- Objective$new(
  f = normal_mixture_llk,
  target = c("mu", "sd", "lambda"),
  npar = c(2, 2, 1),
  data = datasets::faithful$eruptions
)

# definition of the 'Partition' object
partition <- Partition$new(npar = 5, type = "random")

# definition of the 'Optimizer' object with parameter restriction
optimizer <- Optimizer$new(
  which = "stats::optim",
  lower = -5,
  upper = 5,
  method = "L-BFGS-B"
)

# definition of the 'Procedure' object
procedure <- Procedure$new(
  verbose = TRUE,
  minimize = TRUE
)

# alternating optimization
ao(
  objective = objective,
  partition = partition,
  optimizer = optimizer,
  initial   = rnorm(5)
  procedure = procedure
)

}
