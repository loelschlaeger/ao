% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ao.R, R/ao_fixed.R, R/ao_random.R
\name{ao}
\alias{ao}
\alias{ao_fixed}
\alias{ao_random}
\title{Alternating Optimization}
\usage{
ao(
  objective,
  partition = Partition$new(npar = sum(objective$npar), type = "random"),
  optimizer = Optimizer$new("stats::optim"),
  initial = stats::rnorm(sum(objective$npar)),
  procedure = Procedure$new(verbose = TRUE, minimize = TRUE)
)

ao_fixed(
  f,
  initial,
  ...,
  fixed_partition = as.list(1:length(initial)),
  minimize = TRUE,
  iterations = 10,
  tolerance = 1e-06,
  joint_end = FALSE,
  verbose = FALSE
)

ao_random(
  f,
  initial,
  ...,
  new_block_probability = 0.3,
  minimum_block_number = 1,
  minimize = TRUE,
  iterations = 10,
  tolerance = 1e-06,
  joint_end = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{objective}{(\code{numeric()})\cr
The definition of the objective function to be optimized via alternating
optimization, can be created via \code{\link[optimizeR]{Objective}}.}

\item{partition}{(\code{numeric()})\cr
The definition of the target argument partition for alternating optimization,
can be created via \code{\link{Partition}}.}

\item{optimizer}{(\code{Optimizer})\cr
The definition of the base optimizer that solves the optimization problems in
the partitions, can be created via \code{\link[optimizeR]{Optimizer}}.}

\item{initial}{(\code{numeric()})\cr
The starting parameter values for the optimization.}

\item{f}{(\code{function})\cr
A \code{function} to be optimized, returning a single \code{numeric}.
The first argument of \code{f} must be a \code{numeric} of the same length as
\code{initial} followed by any other arguments specified by the \code{...}
argument.}

\item{...}{Additional arguments to be passed to \code{f}.}

\item{fixed_partition}{(\code{list()})\cr
A \code{list} of vectors of indices of \code{initial}, specifying the
partition of the parameter vector in the alternating optimization process.
The default is \code{as.list(1:length(initial))}, i.e. each parameter is
optimized separately. Parameter indices can be members of multiple blocks.}

\item{minimize}{(\code{logical(1)})\cr
Perform minimization? Alternatively, maximization is performed.}

\item{iterations}{(\code{integer(1)})\cr
The maximum number of iterations through the parameter partition before the
alternating optimization process is terminated. Can also be \code{Inf}, in
which case \code{tolerance} is responsible for the termination.}

\item{tolerance}{(\code{numeric(1)})\cr
A non-negative tolerance value. The alternating optimization terminates
prematurely (i.e., before \code{iterations} is reached) if the euclidean
distance between the current estimate and the one from the last iteration is
smaller than \code{tolerance}.}

\item{joint_end}{(\code{logical(1)})\cr
Optimize the parameter set jointly after the alternating optimization process
is terminated?}

\item{verbose}{(\code{logical(1)})\cr
Print tracing details during the alternating optimization process?}

\item{new_block_probability}{(\code{numeric(1)})\cr
The probability for a new parameter block in random partitions.
Values close to 0 result in larger parameter blocks, values close to 1
result in smaller parameter blocks.}

\item{minimum_block_number}{(\code{integer(1)})\cr
The minimum number of blocks in random partitions.}
}
\value{
A \code{list} with the elements
\itemize{
\item \code{estimate}, the optimal parameter vector found,
\item \code{value}, the value of \code{f} at \code{estimate},
\item \code{sequence}, a \code{data.frame} of the function values, estimates and
computation times in the single iterations and parameter blocks,
\item and \code{seconds}, the overall computation time in seconds.
}
}
\description{
Alternating optimization is an iterative procedure for optimizing a
real-valued function jointly over all its parameters by alternating
restricted optimization over parameter partitions.
\itemize{
\item \code{ao} is the most general API
\item \code{ao_fixed} is the special case of a parameter partition that remains fixed
during the alternating optimization procedure
\item \code{ao_random} is the special case of random partitions
}
}
\examples{
# Example 1: Minimization of Himmelblau's function --------------------------

# see https://en.wikipedia.org/wiki/Himmelblau\%27s_function
himmelblau <- function(x) (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2

ao_fixed(
  f = himmelblau,
  initial = rnorm(2),             # random initial value
  fixed_partition = as.list(1:2), # minimize one parameter cond. on the other
  iteration_limit = 10,           # stop after at most 10 iterations
  tolerance_value = 1e-6,         # stop if objective value improvem. <= 1e-6
  verbose = FALSE
)

# Example 2: Maximization of 2-class Gaussian mixture log-likelihood --------

# targets:
# - class means mu (2, unrestricted)
# - class standard deviations sd (2, must be non-negative)
# - class proportion lambda (only 1 for identification, must be in [0, 1])
normal_mixture_llk <- function(mu, sd, lambda, data) {
  c1 <- lambda * dnorm(data, mu[1], sd[1])
  c2 <- (1 - lambda) * dnorm(data, mu[2], sd[2]))
  sum(log(c1 + c2))
}

# overview of the data set
hist(datasets::faithful$eruptions, breaks = 20)

# definition of the 'Objective' object
objective <- Objective$new(
  f = normal_mixture_llk,
  target = c("mu", "sd", "lambda"),
  npar = c(2, 2, 1),
  data = datasets::faithful$eruptions
)

# definition of the 'Partition' object
partition <- Partition$new(npar = 5, type = "random")

# definition of the 'Optimizer' object with parameter restriction
optimizer <- Optimizer$new(
  which = "stats::optim",
  lower = -5,
  upper = 5,
  method = "L-BFGS-B"
)

# definition of the 'Procedure' object
procedure <- Procedure$new(
  verbose = TRUE,
  minimize = TRUE
)

# alternating optimization
ao(
  objective = objective,
  partition = partition,
  optimizer = optimizer,
  initial   = rnorm(5)
  procedure = procedure
)

}
