% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ao.R
\name{ao}
\alias{ao}
\title{Alternating Optimization.}
\usage{
ao(
  f,
  partition,
  initial = 0,
  iterations = 10,
  tolerance = 1e-06,
  minimize = TRUE,
  progress = FALSE,
  plot = TRUE
)
}
\arguments{
\item{f}{An object of class \code{ao_f}, i.e. the output of \code{\link{set_f}}.}

\item{partition}{A list of vectors of parameter indices \eqn{1,...,n} of the function.
For example, choosing \code{partition = list(1, 2, 3, 4, 5, 6, 7, 8, 9)} as
in the example optimizes each parameter separately, while choosing
\code{partition = list(1:9)} leads to joint optimization. Any configuration
in-between is possible, while parameter indices can be members of multiple
subsets.}

\item{initial}{A vector of length \code{f$npar} of initial parameter values. Per default,
the algorithm is initialized at the origin.}

\item{iterations}{The number of iterations through all subsets.}

\item{tolerance}{A non-negative numeric value. The function terminates prematurely if the
euclidean distance between the current solution and the one from the last
iteration is smaller than \code{tolerance}.}

\item{minimize}{If \code{TRUE}, minimization, if \code{FALSE}, maximization.}

\item{progress}{If \code{TRUE}, progress is printed.}

\item{plot}{If \code{TRUE}, the parameter updates are plotted.}
}
\value{
An object of class \code{ao}, which is a list of
\itemize{
\item \code{optimum}, the optimal value,
\item \code{estimate}, the parameter vector that yields the optimum,
\item \code{sequence}, a data frame of the estimates in the single iterations,
\item \code{time}, the total estimation time in seconds.
}
}
\description{
This function performs alternating optimization on the function \code{f}.
}
\details{
This function depends on \code{\link[optimx]{optimx}}.
}
\examples{
valley <- function(x) {
  cons <- c(1.003344481605351, -3.344481605351171e-03)
  n <- length(x)
  f <- rep(0, n)
  j <- 3 * (1:(n/3))
  jm2 <- j - 2
  jm1 <- j - 1
  f[jm2] <- (cons[2]*x[jm2]^3 + cons[1]*x[jm2]) * exp(-(x[jm2]^2)/100) - 1
  f[jm1] <- 10 * (sin(x[jm2]) - x[jm1])
  f[j] <- 10 * (cos(x[jm2]) - x[j])
  sum(f*f)
}
f <- set_f(f = valley, npar = 9, lower = 0, upper = 10, check = FALSE)
ao(f = f, partition = list(1, 2, 3, 4, 5, 6, 7, 8, 9))

}
